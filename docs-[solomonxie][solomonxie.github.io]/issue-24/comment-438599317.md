# ❖ 一个案例了解Python多进程、多线程、协程、高并发处理：自己实现一个简单的Web Server [DRAFT]

Python的多任务处理机制一直在尝试学习，但是阅读很多文章、看了很多教学视频，都还是没太理解，或是记不住。可能不止我一个人是这样。就算写代码练习，一般也都只是多任务处理个简单函数，没什么太大感觉，甚至觉得：有必要么？
受到David Beazley在PyCon 2015演讲中的启发，觉得实现一个简单的Web Server能够将Python多任务机制的优缺点一目了然的呈现出来，而且也是现实世界里真实的需求。
所以决定参考他的视频自己写一个Web Server，从头到尾体验一下各种多任务处理方案。

> 本文将根据David Beazley在PyCon 2015中关于并发技术的演讲，对Python处理并发请求进行各种方案的尝试和学习。

[参考Youtube: David Beazley - Python Concurrency From the Ground Up: LIVE! - PyCon 2015](https://www.youtube.com/watch?v=MCs5OvhV9S4)

这里我们的Web Server将使用简单的`Socket编程`，代码本身不多。至于Socket的具体原理，这里不会太细讲，请自行参考。
另外，为了保证简单，这里的Web Server不处理HTTP交互，而是最单纯的TCP层交互：**也就是说客户端可以随便发送任何内容到服务器如`123abc`，服务器也可以回复任何内容如`hello`，不需要遵守HTTP格式或其它任何格式。**

Python自己写Web Server很简答，只需要几句话操控`socket`即可。然而要实现同时处理`并发请求`，就必须用到`多进程`或`多线程`或`多协程`。

三种方法各有特点：
- `Multiprocessing`多进程：
- `Threading` 多线程：
- `Coroutine` 协程：一般采用第三方库`Gevent`。


为了最好的对比各种多任务处理方式的效果，我们需要一个简单的`task`任务，这里我们用一个最简单的函数：根据序号n，返回斐波纳西数列中序号对应的数字：
```py
# fib.py
def fib(n):
    if n <= 2:
        return 1
    else:
        return fib(n-1) + fib(n-2)
```

不要小看这个简单的函数，如果你执行一句`fib(10)`还好，我在Macbook 2017上，就算执行一句`fib(1000)`都要**接近一分钟才能计算完成**！
选择斐波纳西数列的好处在于，它会随着请求数字增大，处理速度会极速下降。

整个系统的设计是这样的：
**我们创建一个server服务器，接受来自client客户端的请求，客户告诉我们一个数字n，我们就返回斐波纳西数列中n对应的数字。**
如`fib(2)`代表第二个数字，那就是1，`fib(6)`是第六个数字，就是8。

其中，处理task任务的代码是相同的，只是server服务端的多任务处理方式不同。也就是说，下面我们只是创建各种不同的server代码，而task还是用上面的代码而没有变化。

我们先从单一请求的处理开始：完全不顾及并发，一次只处理一个client，多一个client都不接受。



## 「Synchronous」最简单：单进程、单线程处理请求

这也是最简单、最基本的socket操作，代码如下：
```py
# server.py
from socket import *
from fib import fib

def fib_server(address):
    sock = socket(AF_INET, SOCK_STREAM)
    sock.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)
    sock.bind(address)
    sock.listen(5)
    while True:
        client, addr = sock.accept()
        print('Connected', addr)
        fib_response( client )

def fib_response(client):
    while True:
        req = client.recv(100)
        if not req:
            break
        n = int(req)
        result = fib( n )
        resp = b'fib: ' + str(result).encode('ascii') + b'\n'
        client.send(resp)
    print('Closed.')


fib_server( ('localhost', 9999) )
```

其中，`fib_server()`是用来创建一个基本的服务器端socket的，步骤都是很固定的写法，具体怎么理解在这里先不扩展了，只要知道它做的就是：监听指定的某个`IP:Port`，一直循环循环，一旦来了client访问，就马上给出回应。
而`fib_response()`就是具体的回应给client的函数。它做到的是：根据client给的数字，返回`fib()`函数的结果。其中`resp`变量是`client.send()`中的参数，要求必须是010101这样的binary格式，而不是普通的字符串。

然后我们来测试下效果。

首先需要让Server运行起来，即`$ python server.py`即可开启一个”持久运行“的监听`localhost:9999`的Web服务器。
然后在另一个Shell中，我们模拟客户端来访问这个服务器，并和它交互。两种非常好用的方法：一个是`nc`命令(推荐)，一个是`telnet`命令。两个程序都用来与服务器交互。
用nc连接服务器只需要：`$ nc localhost 9999`即可建立连接，进入交互阶段。随便输入一个数字，就会在当前Shell中获得服务器返回的结果。比如输入`1`返回`1`，输入`6`返回`8`。如下：

![rec](https://user-images.githubusercontent.com/14041622/52897621-aaa0ab80-3211-11e9-8642-433b49bcb6f8.gif)

但是这个最简单的Server有一个致命缺点——同一时间只能接收一个client客户，如果有另一个客户，就会排队等待，直到前一个客户退出连接。展示效果如下：

![rec](https://user-images.githubusercontent.com/14041622/52898449-26eabd00-3219-11e9-81c7-9a7a64e0eadd.gif)



## 「Multi-processing」多进程处理请求

即，每次来了一个新的client发出请求，Python就新开一个processor进程，来专门处理他的请求。
（一般每个进程耗费几MB以上内存）

代码如下：
```py

```


## 「Multi-thread」单进程多线程处理请求

由于每次开一个进程所耗费的内存太大，一个client几MB，仅一万个请求就要耗费10GB内存，这不太现实。所以可以采用在一个进程内，创建多个线程的方式。

代码如下：
```py

```

## 「Non-blocking Socket」单进程单线程之采用非堵塞处理多请求

Python中，`socket`都可以设置为`非堵塞`方式，即`accpet()`和`receive()`方法执行时可以不用等待，而直接执行下一步。
这样一来，就可以直接利用LOOP循环完成无限多任务的处理。
唯一要注意的是：
- 当`accpet()`没有接收到任何客户端连接时，就着急去执行下一步，**会产生异常**。
- 当`receive()`没有接收到任何客户端发送数据时，就着急去执行下一步，**会产生异常**。

所以需要采用`try...catch`异常处理来完成这个功能。
代码如下：
```py

```
![image](https://user-images.githubusercontent.com/14041622/48495108-41a04500-e86a-11e8-8871-e5da03a39519.png)


## 「Coroutine」单进程单线程之采用协程处理多请求

[参考：协程 - 廖雪峰Python教程](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001432090171191d05dae6e129940518d1d6cf6eeaaa969000)

客户数量过大时，即使是`多线程`也扛不住。那么最近开始的`协程方案`就开始被Python引入了。

> `Corotine协程`是Python中`异步IO`中的知识点。

Python中协程的流行方法是，使用第三方库`gevent`来创建。

代码如下：
```py

```
![image](https://user-images.githubusercontent.com/14041622/48495231-7f04d280-e86a-11e8-988e-23d57d860ad0.png)
