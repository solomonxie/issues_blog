# ❖ Python高级语法之：yield与Generator生成器详解 [DRAFT]

[参考：Python yield 使用浅析 - IBM](https://www.ibm.com/developerworks/cn/opensource/os-cn-python-yield/index.html)

Python高级语法中，由一个`yield`关键词生成的`generator`生成器，是精髓中的精髓。它虽然比装饰器、魔法方法更难懂，但是它强大到我们难以想象的地步：小到简单的for loop循环，大到代替多线程做服务器的高并发处理，都可以基于`yield`来实现。


## 理解yield

简单来说，`yield`是代替`return`的另一种方案:
- `return`就像人只有一辈子，一个函数一旦return，它的生命就结束了
- `yield`就像有“第二人生”、“第三人生”甚至轮回转世一样，函数不但能返回值，“重生”以后还能再接着“上辈子”的记忆继续返回值

**我的定义：`yield`在循环中代替`return`，每次循环返回一次值，而不是全部循环完了才返回值。**

一般我们进行循环迭代的时候，都必须等待循环结束后才return结果。
数量小的时候还行，但是如果循环次数上百万？上亿？我们要等多久？
如果循环中不涉及I/O还行，但是如果涉及I/O堵塞，一个堵几秒，后边几百万个客户等着呢，银行柜台还能不能下班了？

所以这里肯定是要`并行处理`的。除了传统的多线程多进程外，我们还可以选择Generator生成器，也就是由`yield`代替return，每次循环都返回值，而不是全部循环完了才返回结果。

这样做的好处就是——极大的节省了内存。如果用return，那么循环中的所有数据都要不断累计到内存里直到循环结束，这个不友好。
**而yield则是一次一次的返回结果，就不会在内存里累加了。所以数据量越大，优势就越明显。**

**有多明显？如果做一百万的简单数字计算，普通的for loop return会增加300MB+的内存占用！而用yield一次一次返回，增加的内存占用几乎为0MB！**


### yield的位置

既然`yield`不是全部循环完了再返回，而是循环中每次都返回，所以位置自然不是在for loop之后，而是在loop之中。

先来看一般的for loop返回：
```py
def square(numbers):
    result = []
    for n in numbers:
        result.append( n**2 )
    return result    #在for之外
```

再来看看yield怎么做：
```py
def square(numbers):
    for n in numbers:
        yield n**2    #在for之中
```
可以看到，yield在for loop之中，且函数完全不需要写return返回。

这时候如果你`print( square([1,2,3]) )`得到的就不是直接的结果，而是一个`<generator object>`。
如果要使用，就必须一次一次的`next(...)`来获取下一个值：
```py
>>> results = square( [1,2,3] )
>>> next( result )
1
>>> next( result )
4
>>> next( result )
9
>>> next( result )
ERROR: StopIteration
```

这个时候更简单的做法是：
```py
for r in results:
    print( r )
```
因为`in`这个关键词自动在后台为我们调用生成器的`next()`函数


什么是generator生成器？
只要我们在一个函数中用了`yield`关键字，函数就会返回一个`<generator object>`生成器对象，两者是相辅相成的。有了这个对象后，我们就可以使用一系列的操作来控制这个循环结果了，比如`next()`获取下一个迭代的结果。

`yield`和`generator`的关系，简单来说就是一个起因一个结果：只要写上yield, 其所在的函数就立马变成一个`<generator object>`对象。



## xrange：用生成器实现的range

Python中我们使用`range()`函数生成数列非常常用。而`xrange()`的使用方法、效果几乎一模一样，唯一不同的就是——`xrange()`返回的是生成器，而不是直接的结果。
如果数据量大时，`xrange()`能极大的减小内存占用，带来卓越的性能提升。

当然，几百、几千的数量级，就直接用range好了。




## 多重yield

有时候我们可能会在一个函数中、或者一个for loop中看到多个`yield`，这有点不太好理解。




## `yield from`与`sub-generator`子生成器

子生成器主要用到`yield from`关键词




## 递归中使用yield

有时候yield就可以解决递归的问题，但是有时候解决不了，还是要用递归。然后递归的同时还想达到yield的效果，就需要动点脑子了。

[参考：Recursion using yield](https://stackoverflow.com/questions/8991840/recursion-using-yield)

```py
def recursion(self, num):
    result = num**2
    yield result
    if num < 100:
        yield from self.recursion(result)

for rec in recursion(100):
    print( rec )
```
