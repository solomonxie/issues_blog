# epoll方式 (从HTTP Server角度看）

`epoll`是Linux内核采用的处理多任务高并发的一种方式。不同于多线程、多进程、协程、非阻塞等方式，epoll只通过单进程、单线程即可完成多任务同时处理。

但是epoll和其它那些有本质上的区别：多进程、多线程、协程无论怎么运用，都逃不出`Application`的内存空间，之后还是要一个一个的**复制**到Kernel内核中去运行，而且还不是一口气，需要和其它application应用程序互相穿插着、排队去kernel运行。
但是由于我们要处理的是`高并发socket`问题，那就必然遇到某一些socket等待对方传数据的过程，这就造成了对kernel的极大浪费。

**而`epoll`的作用就是，让我们“跳出”Application的盒子，达到Kernel内核级的运算。**

> 现今所有流行的HTTP Servers都是采用的epoll方式来加速处理多任务，包括Apache、Nginx等。包括协程的Python库gevent也是采用epoll底层处理。所有这些多进程、多线程、协程、非堵塞的方式，在和epoll高效率比起来，都是一个天上一个地下。这也就是为什么epoll这么流行的原因。

基本原理：
- 首先要理解，操作系统的内存分配中，Kernel必须独占空间不能被App应用程序使用（否则相当于被黑客随便使用），App程序的内存空间也是互相隔离开的。
- 但是每次app都把数据copy到kernel内核中，就导致高并发时效率低下的问题。
- 于是产生了`epoll`方式：即在内存中创建一片**独立的**空间，让Kernle和App共用。这样一来二者互不干扰，还能互相协作。


IO多路复用
就是`select`, `poll`, `epoll`，即`Event driven I/O`的IO方式。


基本工作方式：
采用`select -> poll -> epoll`模型，不断循环，不断轮询所有socket，只有当某个socket的数据变化了（接收到数据了），才通知用户进程来处理。