# Python装饰器 [DRAFT]

极简样式：
```py
# Define a decorator
def outter(func):
    def alternative():
        # ...Some code here...
        result = func()
        # ...Some code here...
        return result

    return alternative

# Apply a decorator
@outter
def stable_method():
    pass
```

标准样式：
```py
# Define a decorator
def outter(func):
    def alternative(*args, **kargs):
        # ...Some code here...
        result = func(*args, **kargs)
        # ...Some code here...
        return result

    return alternative

# Apply a decorator
@outter
def stable_method():
    pass
```

装饰器带参数样式：
```py
# Define a decorator
def outter(name):
    def inner(func):
        def alternative(*args, **kargs):
            print('I can use name={} here'.format(name))
            # ...Some code here...
            result = func(*args, **kargs)
            # ...Some code here...
            return result

        return alternative
    return inner

# Apply a decorator
@outter(name='Jason')
def stable_method():
    pass
```


## 类中定义装饰器

[参考：Decorator inside Python class](https://medium.com/@vadimpushtaev/decorator-inside-python-class-1e74d23107f6)



## 目的是给被装饰方法传参数的装饰器

假设我有一个功能方法，叫`do_something(what, how=None)`，第一个参数我肯定会给，但是第二个参数我想从装饰器里给，也就是在不改变代码的情况下做到这个情况。Python需要用到装饰器来达到。

注意：这种目的是给目标method传送参数值的装饰器，**必须是三层嵌套！**

```py

def tell_you_how():
    """Decorator for the purpose of passing a value to the target function"""

    def decorator():
        def wrapper():
            pass

@tell_you_how
def do_something(what, how=None):
    print('I am doing {}', how)

do_something("jogging")
```