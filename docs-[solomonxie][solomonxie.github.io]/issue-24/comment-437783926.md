# Python模块


## if __name__ == "__main__"
一般如果是个可以独立运行的模块(.py)文件，则可以定义一个入口：
```py
def main():
    # Only to call functions, 
    # NO code for implementation should be written here
    pass

if __name__ == "__main__":
    main()
```

## 导入模块方式

```py
# @1: Import all methods, 
#     NEED to specify module's name when use methods
#     etc., MOD.FUNC(), MOD.SUBMOD.FUNC()
import MOD
import MOD.SUBMOD

# @2: Declare methods to import, 
#     NO need to specify module's name when use methods
#     etc., FUNC()
from MOD import *
from MOD import METHODS
from MOD.SUBMOD import METHODS

# @3: Import local package
```

## 被导入模块中的公用变量

如果在一个`common.py`中定义一个全局变量`PUBLIC_VARIABLE`，那么在别的模块中import时，也能够使用这个公用变量。
但是，
这两种方法导入公用变量后情况会有不同：
- `import MOD`: 这种引入方法，由于调用时是用`MOD.PUBLIC_VARIABLE`来使用，所以这个公用变量在一处被修改后，其它所有引用它的文件中，变量都会变动。
- `from MOD import PUBLIC_VARIABLE`：由于调用时是用`PUBLIC_VARIABLE`，只相当于生成了一个本地的`global variable`，那么无论怎么修改，也不会影响其它文件所引用的这个变量。


## Python Package

Python里，就像所有的`.py`文件被称为`Module`模块一样，所有的文件夹都被称为`Package`包。前提是，这个文件夹里有一个`__init__.py`文件，可以是空文件也可以有一些方便都内容。

一旦一个文件夹可以被视为`Package`，那么其中的所有文件都会有独立的Namespace命名空间，即变量都不共享，与其它的package完全独立。一个项目里，可以有很多个子文件夹、子子文件夹，一旦变成package，那么它们都能互相独立，方便我们引用。

在Python的运行一个`.py`脚本的时候，会自动将`sys.path`设置为**脚本所在目录**。然后凡是这个`sys.path`之下的所有的文件模块，都能直接import导入。

**但是，很明显的，只有这个`.py`脚本之内的目录才包括在path里，也就是说它之外的所有事情它都一无所知。**

那么问题来了：怎么导入父级目录中的其它模块或包呢？

### 父目录模块导入

现在有目录结构如下：
```sh
Project
├── main.py
├── sub1
│   ├── common.py
│   ├── mod1.py *
└── sub2
    ├── common.py
    └── mod2.py *
```

目的：在`sub1/mod1.py`中，导入`sub2/mod2.py`。同时，`mod2.py`中还需要导入同目录的`common.py`才能工作。

要达到这一步，我们需要同时修改两个文件`mod1.py`和`mod2.py`：
```py
#FILE: sub1/mod1.py
import sys
sys.path.append('..')
# Import the module
import sub2.mod4

#FILE: sub2/mod2.py

import sys
sys.path.append('.')
#...
```

解释一下：
`sub1/mod1.py`中，因为它的`sys.path`默认只是当前目录以下的内容，所以python解释器对它之外完全不知情。所以我们用`sys.path.append('..')`方法把父级目录也包括进来了，这样python解释器就能向下搜索，找到指定的包了。
`sub2/mod2.py`中，它独立运行的时候，直接引用同目录的模块是没问题的。但是现在情况是，我们是从`sub1/mod1.py`这个位置执行的脚本，那么相当于`sys.path -> /project/sub2/`，这个时候python解释器无法从`sys.path`中找到`mod2.py`所依赖的包。
所以我们要在`mod2.py`中将自己所在的目录添加到`sys.path`中，这样即能找到了。

总结：
为了保证自己运行正确、同时被引用时也能正常使用，我们最好给每个`.py`文件头部都加入`sys.path.append('.')`。如需调用父级包，那么再加一句`sys.path.append('..')`即可。


