# 异步IO  Asynchronous I/O

> "IO编程中，Stream（流）是一个很重要的概念，可以把流想象成一个水管，数据就是水管里的水，但是只能单向流动。Input Stream就是数据从外面（磁盘、网络）流进内存，Output Stream就是数据从内存流到外面去。" - 阮一峰

[参考：异步IO - 阮一峰官网](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143208573480558080fa77514407cb23834c78c6c7309000)

编程时我们常面对的I/O有：
- 磁盘I/O：就是我们常用的`file.open("/path/to/file")`等语句直接读取本地文件。
- 网络I/O：就是`socket.receive()`和`socket.accpet()`这样的与别的电脑沟通的语句。
- 内存I/O：就是`StringIO.write()`和`STRINGIO.getvalue()`等直接在内存里读写的语句。

内存的IO读写极快，远远远高于磁盘和网络的IO读取写入。比如要把100M的数据写入磁盘，CPU输出100M的数据只需要0.01秒，可是磁盘要接收这100M数据可能需要10秒。
如果不涉及IO读取写入，CPU执行代码速度是极快的，一旦碰上了需要读写的地方，就要停下来等着**龟速**的IO完成，再执行下一句。

这就造成了严重的拖累，这不合理。处理的事情少的时候还好说，一旦遇到高并发要求这是一个必须要解决的问题。

所以就出现了`异步IO`这个策略。

所有的IO都存在一样的共性：堵塞。
根据IO是否堵塞，分为了这两种：
- 同步IO (Synchronous I/O)：程序遇到IO读写时，要停下来等待其完成才执行下一句。
- 异步IO (Asynchronous I/O)：程序遇到IO读写时，不等待而直接执行下一句。

但是，如果没有接收到上一步IO的值，之后的代码都没法正常执行啊？
所以，正常的运行逻辑是不行的，必须改变代码逻辑才能使用`异步IO`。
我们称这种逻辑为：`异步IO模型`.