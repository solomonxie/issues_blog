# Network Protocols 网络协议学习

[Refer to Wiki: Internet protocol suite](https://www.wikiwand.com/en/Internet_protocol_suite)

![image](https://user-images.githubusercontent.com/14041622/48396713-525f9680-e756-11e8-820e-100216d7eb44.png)

网络传输，较基础的、我们常接触的是TCP或UDP协议，其它各种高级协议如HTTP、FTP、Webdav等都是建立于这些协议之上的。

互联网协议的整体结构如下：
- Physical Layer
    - Internet Layer (IP, ICMP)
        - Transport Layer (TCP, UDP)
            - Application Layer (HTTP, FTP)

我们经常接触的主要是中高层协议。一些常用的协议和访问软件如下：
- TCP
    - HTTP /  HTTPS    <<<  `Chrome Browser`
        - Webdav   <<< `Cyberduck`
    - FTP   <<< `Filezilla`
    - SSH   <<< `Terminal`
    - SMTP (Mail)    <<< `Email client`
    - DNS
    - Shadowsocks   <<< `SS client`
    - VNC / RDP (Remote Desktop)    <<< `Remote desktop client`
- UDP
    - DHCP
    - IPTV

> `TCP`和`UDP`是较为基层的`传输层`协议，在其之下是更底层的IP网络层和Pysical物理层，而在其之上是可以发展出繁多的高级`应用层`协议：如HTTP, FTP, VNC等。


## TCP与UDP

理解：
- UDP：相当于`写信`的模型。只要知道对方地址，发出去就行了。能不能到就不管了。
- TCP：相当于`淘宝购物`的模型。先给商家“下订单”，然后商家发货到你的地址。如果收货时发现东西不对，就告诉商家，就再给你发一个正确的包裹。

流程区别：
- UDP只要简单的`sendto`和`receive`即可。
- TCP在`sendto`和`receive`之前，先要进行一系列的连接验证：三次握手，握手成功后，才允许你开始发送和接收数据。在数据传输完成之后，还要进行四次握手，才能关闭连接。

UDP特点：
- 简单、快：1.创建socket，2.发送。
- 丢包。
- 不安全，可以被任何中间人捕获。

TCP特点：
- 面向连接：三次握手、四次挥手
- 确立连接复杂，所以更耗时间
- 更稳定：也丢包，但是有保障措施：如果发现丢包，就再发一遍。

电脑里所有的`下载`，都会有相应的`上传`，这个上传即为TCP中的应答所发送的数据，告之服务器自己已经收到。


### TCP 三次握手 Three Way Handshake

> **记住：TCP`三次握手`，是两台电脑互相证明对方聋不聋、哑不哑的过程。只有证明了双方都能听能说，才能进入正式的沟通。**

TCP规定，在正式传输数据之前，两台电脑必须先建立**可靠的连接**：逻辑上说，最少需要`三次握手`。

简单说就是这三步：
- @1: Client对Server说，“我想跟你说点事，你听见了吗？”
- @2: Server回复说，“我不聋，我听见了你了，你能听见我吗？”
- @3: Client对Server说，“我也听见你了，我也不聋。”

其中，
第一次握手，是Client在测试Server是不是聋子，也就是看他能不能工作。
第二次握手，是Server回复Client证明自己不聋也不哑，但也得试试Client聋不聋。
第三次握手，是Client向Server回复，证明自己也不聋也不哑。

逻辑上，至少经历过这三步，才能证明双方都不聋也不哑，都能正常沟通。
**只要证明这点，就可以正式开始沟通、传数据了。**

那么，要实现这个证明题，我们需要用编程来实现。下面是`三次握手`的编程实现方式。

三次握手的编程实现，采用了很简单的方式：
- @1: Client向Server发送一个随机数字，比如`7543`。
- @2: Server收到随机数字`7543`，为了证明自己收到了，他把这个数+1，回复给Client，即`7544`。同时，又想测试Client聋不聋，就发另一个随机数字给Client，比如`1333`。
- @3: Client收到一个`7544`和`1333`，知道其中一个是自己发的数字+1，说明Server听到了。但是为了证明自己也不聋，就把`1333`+1返还给Server。Server接到`1334`后知道对方也不聋，也就是说这道“双方都不聋不哑”的证明题完成了，可以开始正式沟通了。然后Server就开始等待Client发来的具体信息。

其中，Client先发的随机数，名叫`SYN`（Synchronize)，
Server后发的一个随机数，名叫`ACK`（Acknowledgement)。

所以三次握手分别发送了这几个包：
- Client -> Server: SYN(client) = 随机数
- Server -> Client: ACK-SYN, 其中这个ACK = SYN(client)+1，SYN(server) = 随机数
- Client -> Server: ACK，其中ACK = SYN(server)+1

注意，其中SYN**总是**重新创建的随机数，而ACK**总是**所收到的SYN+1。从语意上也能够理解这点：为了Synchronize而创建随机数，为了代表Acknoledgement而在synchronize上+1。所以，全过程产生了两个完全不同的SYN随机数，和两个基于每个SYN的ACK。

### TCP四次挥手

TCP规定，在完成传输数据后，两台电脑必须进行四次挥手，才能关闭连接。逻辑上，也确实最少需要四步才能做到。


## HTTP协议

注意事项：
- Browser区分Response回复的Header和Body的方法：Header各个值之间是紧凑的，一旦遇到空行，则视为开始Body内容。所以Body一定要与Header内容空开一行！


