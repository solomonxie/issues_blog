# Bash脚本判别使用者的身份

经常要在bash脚本里面或者直接对脚本本身加上`sudo`运行命令，但是这引发了一系列的问题。

比如用sudo的时候，脚本里的`~`或`$HOME`指代用户文件夹的这个变量，到底是应该指向我真正的用户文件夹如`/home/pi`呢，还是指向了超级管理员的用户文件夹`/root/`呢？

实际上它指向了`/root/`文件夹，这是我们绝对不想要的。但是很多命令如安装个程序，都不得不用`sudo`，那怎么办？

首先要说下经验：命令行的权限执行，从表现上来看，可以分为以下5种情况：
- `admin-manual`: 普通用户手敲命令
- `sudo-manual`: 手敲命令加sudo
- `admin-bash`: 以普通用户执行bash脚本
- `sudo-bash`: 以sudo执行bash脚本
- `root-any`: 以root用户登录

很多变量、环境变量在这4中情况下，会经常出现混乱！（混乱指的是我们自己，不是电脑）

另外，说个小技巧。
我们都直到`~`变量是指向`当前`用户目录，实际上`~abc`格式的变量可以指向`指定用户的`用户目录，如`~pi`会指向`/home/pi`，或`~ubuntu`指向`/home/ubuntu`.

为了能检测出正确的用户和用户路径，我做了以下测试，并分别用普通用户`pi`执行和用sudo执行：

```sh
# 简单说明当前的权限者是谁（不推荐！）
$ whoami
(sudo)>>> root
(admin-manual) >>> pi

# 不同于whoami，能够指出当前有哪些用户登录电脑，包括本机登录和ssh登录的所有人
$ who am i
(sudo)>>> pi       tty1         2018-11-25 04:18
(admin-manual) >>> pi       tty1         2018-11-25 04:18

# 等同于whoami （不推荐！）
$ echo $USER
(sudo)>>> root
(admin-manual) >>> pi

# 用户主目录位置 (不靠谱不推荐！）
echo $HOME
(root)>>> /root
(pi) >>> /home/pi

$ 用户主目录位置，等同于$HOME （不推荐！）
$ echo ~
(root)>>> /root
(pi) >>> /home/pi


# 直接使用环境变量LOGNAME
$ echo $LOGNAME
(sudo)>>> pi
(admin-manual) >>> pi

# 显式调用环境变量LOGNAME （不推荐）
$ printenv LOGNAME
(手敲)>>> pi
$ sudo printenv LOGNAME
(手敲)>>> root


# SUDO_USER是root的ENV中的环境变量，
# 但是直接打印$SUDO_USER是空的，要用比如~abc格式
# 同时普通用户的env是没有的，只有root用户才能显示出来
$ echo ~$SUDO_USER
(root)>>> /home/pi
(pi) >>> /home/pi

# SUDO_USER是root的ENV中的环境变量，
# 但是直接打印$SUDO_USER是空的，要用比如~abc格式
# 同时普通用户的env是没有的，只有root用户才能显示出来
$ sudo echo ~$SUDO_USER
(pi) >>> /home/pi


# 显示的调用环境变量SUDO_USER 
$ printenv SUDO_USER
(手敲)>>> 内容为空
(脚本)>>>
$ sudo printenv SUDO_USER
(手敲)>>> pi
(脚本)>>>
```

从上面测试中可以看出，如果我们是用sudo执行bash脚本的话，很多变量都是“不靠谱”的。
Stackoverflow中，比较一致性的倾向就是使用`$SUDO_USER`这个环境变量。直接echo打印不出来，需要用`~<用户名>`这样的格式才能显示出来。

但是问题是，如`SUDO_USER`和`LOGNAME`都是环境变量，而环境变量是最容易随环境而改变的！也就是不靠谱！从以上的测验中也可以看到是有多靠谱了：手敲、脚本里、外面sudo、里面sudo，得出来的答案都不统一！

有没有什么方法不用环境变量呢？
看来，`who am i`命令是最好的方法，简单的截取一下其中的用户名，在用`~abc`的形式就能得到用户的目录了。

如下：
```sh
$ echo ~$(who am i | awk '{print $1}')
(手敲)>>> /home/pi
(脚本)>>> ~pi
```

这时候问题又出现了：手敲时候，我们可以获得`~pi`的正确地址，但是脚本中却不识别`~pi`是个什么东西，顶多是个字符串，没法像变量一样。
那既然是这样，我们就不能用`~abc`方法了，改用虽然老套但是绝对不混乱的方法：
从`/etc/passwd`中直接看。

手动的话可以直接打开passwd查看，脚本里面就比较麻烦，最方便的是用系统命令`getent`即Get Entries命令，获得指定用户的信息：
```sh
$ getent passwd pi
>>> pi:x:1000:1000:,,,:/home/pi:/bin/bash
```

那么，剩下的是有把其中的`/home/pi`取出来了，我们用`cut`就轻松取出。
所以全部过程如下：
```sh
house=`getent passwd $(who am i | awk '{print $1}') | cut -d: -f 6`
```
顺利得到`/home/pi`！