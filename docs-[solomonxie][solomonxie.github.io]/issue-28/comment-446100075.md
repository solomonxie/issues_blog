# SQLAlchemy中的表关系 Table Relationships 


## 为什么需要手动定义Relationships

在相关联的表中，我们可以不创建表关联的定义，而只是单纯互相引用id即可。但是，查询和使用起来就要麻烦很多：
```py
＃给定参数User.name,获取该user的addresses
# 参考知乎：https://www.zhihu.com/question/38456789/answer/90470689

def get_addresses_from_user(user_name):
    user = session.query(User).filter_by(name=user_name).first()
    addresses = session.query(Address).filter_by(user_id=user.id).all()
    return addresses
```

可以看到，这样的效率非常低。
好在原生的SQL就有relationship设置，SQLAlchemy将其引入到了ORM模型中。

**它可以让我们只在表中声明表之间的关系，之后每次使用就完全无需手动`交叉搜索`，而是像对待一个表中的数据一样直接使用。**



## relationship() 函数

[参考官方文档：Linking Relationships with Backref](https://docs.sqlalchemy.org/en/rel_1_0/orm/backref.html#relationships-backref)

SQLAlchemy创建表关联时，使用的是`relationshi()`这个函数。
它返回的是一个类的属性，比如father类的`children`属性。但是，它实际上并没有在father表中创建任何叫children的列，而是自动帮你到相关联的children表中去找数据，让你用起来感觉没有差别而已。
这是非常方便的！

`relationship()`这个函数的参数非常多，每一个参数都有很多内容需要理解。因为所有的表关联的形态，都是在这个函数里面定义的。
以下分别讲解。


## Reference 正向引用

传统的方法，是在父类中定义一个`关系 relationship`或叫`正向引用 Reference`，子类只需定义一个外键。比如：
```py
class Father(..): 
    id = Column(..)
    children = relationship('Child')

class Child(..):
    father_id = Column( Integer, ForeignKey('father.id') )

# 添加数据
daddy = Father()
jason = Child()
emma = Child()

# 将孩子挂到父亲名下
daddy.children.append(jason)
daddy.children.append(emma)
```
这样当每次我们使用`father.children`的时候，就会自动返回与这个father相关联的所有children了。



## Back Reference 反向引用

单纯定义的`relationship('子类名')`只是一个正向引用，也就是只能让父类调用子对象。反过来，如果要问children他们的父亲是谁，就不行了。

**所以，我们还需要一个`反向引用 (Back Reference)`的声明，让子对象能够知道父对象是谁。**

定义方式是在父类的relationship(..)中加一个参数`backref`：
```py
class Father(..): 
    children = relationship( 'Child', backref='parent' )
```
注意：
1. backref参数里面使用的随便写，主要用于之后子类的引用。
2. backref参数是`双向性`的，意思是，只需要在父类中声明一次，那么`父⇄子`的双向关系就确立了，不用再去子类中写一遍。

这时候，我们在添加就可以这样互相调用了：
```py
>>> Jason = Child()
>>> print( Jason.parent )
 <__main__.Father object at 0x10222f860>
```


## Bidirectional & Unidirectional Back Reference 双向和单向的反向引用

后来，SQLAlchemy发现这种只在一边定义双向性`backref`的方法有点不太直观，所以又添加了另一个参数`back_populates`参数，而这个back_populates参数是单向性的，也就是说：
你要确立双方向关系就必须在两边的类中都声明一遍。这样比较直观。

比如：
```py
class Father(..): 
    id = Column(..)
    children = relationship( 'Child', back_populates='parent' )

class Child(..):
    father_id = Column( Integer, ForeignKey('father.id') )
    parent = relationship( 'Father', back_populates='children' )
```

**注意：`back_populates`要求父类子类的关系名称必须严格“对称”：**
- 父类的relationship属性名`children`，必须对应子类的关系中的`back_populates`中的值
- 子类的relationship属性名`parent`，必须对应父类的关系中的`back_populates`中的值

这样一来利用`反向引用`参数创建的关系就确立了。但是注意，
无论用`backref`还是`back_populates`创建的关联，如果我们必须要为父子对象添加对象间的关联才能引用，否则谁也不知道谁是谁的父亲、儿子：
```py
>>> daddy = Father()
>>> son = Child()
>>> daughter = Child()

>>> daddy.children
[]
>>> son.parent
None

>>> daddy.children.append( son )
>>> daddy.children.append( daughter )

>>> daddy.children
[ <Child ...>, <Child ...> ]

>>> son.parent
<Father ...>
```

另外：上面添加父子关系的时候，不光可以用`daddy.children.append`，
还可以在声明子对象的时候确定：`son = Child( parent=daddy )`


`反向引用`参数对比：
- `backref`参数：双方向。在父类中定义即可。只能通过`daddy.children.append()`方式添加子对象关联。
- `back_populates`参数：单方向。必须在父子类中都定义，且属性名称必须严格对称。还可以通过`Child(parent=daddy)`的方式添加父对象关联。



## Lazy Load 参数

[参考：flask-sqlalchemy中的lazy的解释](https://shomy.top/2016/08/11/flask-sqlalchemy-relation-lazy/)

SQLAlchemy的`relationship( ..., lazy='??' )`方法中的`lazy`参数一直是初学最容易困扰的地方。

`Lazy Load Methods`是SQLAlchemy为多表关联而定义的一系列加载方法。为lazy参数选择什么值，决定了 SQLAlchemy 什么时候从数据库中加载数据。每种方法的对应着SQL语句中多表关联的一种写法，所以优缺点、效率高低各有不同。

`lazy`参数的可选方法有：
- `select` - (默认) 后台会用select语句一次性加载所有数据，即访问到属性的时候，就会全部加载该属性的数据。
- `joined` - 数据会被JOIN语句加载，即对关联的两个表进行join操作，从而获取到所有相关的对象。
- `subquery` - 数据被用subquery子查询SQL语句加载
- `dynamic` - 在访问属性的时候，并不在内存中加载数据，而是返回一个query对象, 需要执行相应方法才可以获取对象。适用于数据量大的时候。 
- `immediate` - items should be loaded as the parents are loaded, using a separate SELECT statement, or identity map fetch for simple many-to-one references.
- `noload` - no loading should occur at any time. This is to support “write-only” attributes, or attributes which are populated in some manner specific to the application.
- `True` - 即 'select'方法
- `False` - 即 'joined'方法
- `None` - 即'noload'方法


下面用`School`和`Students`的实例来看各种方法的不同。

假设定义两个ORM类：
```py
class School(..):
    id = Column(..)
    students = relationship( 'Student', backref='school' )

class Student(..):
    id = Column(..)
    school_id = Column(.., ForeignKey('school.id') )
```

上例中我们建立了一个普通的两表关联：`students = relationship( 'Student', backref='school' )`。
默认情况下，参数`lazy`为select，我们不写也可以）。
也就是说，如果定义`lazy='select'`，那么当我们要进行搜索引用时（假设表中已有数据）：
```py
>>> school_01 = School.query.first()  # 随便获取一个数据库中已有的school
>>> school_01.students
[ <Student: u'test'>, <Student: u'test2'>, <Student: u'test3'> ]
```
可以看到，`lazy='select'`会简单直接的返回所有相关联的数据。
但是，如果数据量非常大：比如百万级，这种全部返回就不理智了，因为会大量侵占内存。
所以我们可以选择`lazy='dynamic'`，即只返回一个`query`查询对象，供你手动加条件查询，比如`query.all()`或`query.filter()`等。

假设我们将之前的定义改为：`students = db.relationship('Student', backref='_class', lazy="dynamic")`。那么：
```py
>>> school_01.students
<sqlalchemy.orm.dynamic.AppenderBaseQuery object at 0x7f007d2e8ed0>

>>> print( school_01.students )
SELECT students.id AS students_id, students.name AS students_name
FROM students, registrations
WHERE :param_1 = registrations.class_id AND students.id = registrations.student_id

>>> school_01.students.all()
[ <Student: u'test'>, <Student: u'test2'>, <Student: u'test3'> ]
```
可以看到, 执行`school_01.students`返回的只是一个`query`对象，甚至说只是返回了一条SQL
语句，就是没有具体数据。可以想像这个消耗的时间相当于0了。
而如果`lazy=select 或者 joined`均是直接返回结果。　

需要注意的是，
**`lazy="dynamic"`只可以用在一对多和多对对关系中，不可以用在一对一和多对一中。**

这样也合理：如果返回结果很少的话，就没必要延迟加载数据了。 

### backref(..., lazy=...) 反向引用的lazy加载

直接给`relationship(.., lazy='??')`，只是给`正向引用`设置加载方法。
实际上`反向引用`也是可以设置lazy加载方法的。
做法就是：使用`backref(..)`函数：
```py
    students = relationship(..., lazy='..', backref=backref('Student, lazy='dynamic') )
```
可以看到，`backref(..)`函数返回的是一个`backref`参数专用的值，在这里面可以指定反向引用的加载方法。




## SQL中的表关系

对应关系：
- One to Many 一对多： 
- Many to One 多对一：
- Many to Many 多对多：



### One to Many 一对多

建立一个`One-to-Many`的多表关联，假设是一个人对应多条狗：
```py
# ...
from sqlalchemy.orm import relationship

class Person(Base):
    id = Column(...)
    name = Column(...)
    pets = relationship('Pet', backref='owner')
    # 上面这句是添加一关联，而不是实际的列
    # 注意：1. 'Pet'是大写开头，因为指向了Python类，而不是数据库中表
    # 2. backref是指建立一个不存在于数据库的“假列”，
    # 用于添加数据时候指认关联对象，代替传统id指定


class Pet(Base):
    id = Column(...)
    name = Column(...)
    owner_id = Column(Integer, ForeignKey('person.id')
    # 上面这句添加了一个外键，
    # 注意外键的'person'是数据库中的表名，而不是class类名，所以用小写以区分
```

创建好关联的表以后，我们就可以直接插入数据了。注意，插入带关联的数据也和SQL插入有些不同：
```py
#...

# 添加主人
andy = Person(name='Andrew')
session.add( andy )
seession.commit()

# 添加狗
pp01 = Pet(name='Puppy', owner=andy)
pp02 = Pet(name='Puppy', owner=andy)
# 注意这句话中，owner是刚才主表中注册relationship中的backref指定的参数名，
# 传给owner的是主表的一个Python实例化对象，而不是什么id
# 看起来复杂，实际上sqlalchemy可以自动取出object的id然后匹配副表中的foreignkey。

session.add(pp01)
session.add(pp02)
session.commit()

print( andy.pets )
# >>> [<Pet 1>, <Pet, 2>]
# 返回的是两个Pet对象

print( pp01.owner )
# >>> <Person 'Andrew'>
# 同样，副表中利用owner这个backref定义的假列，返回的是Person对象。
```



### Many to One 多对一

比如职工和公司的关系就是多对一。这和公司与职工对一对多有什么区别？
区别其实是在SQL语句中的：多对一的关联关系，是在多的一方的表中定义，一的一方表中没有任何关系定义：
```py
class Company(...):
    id = Column(...)

class Employee(..):
    id = Column(...)
    company_id = Column( ..., ForeignKey('company.id') )
    company = relationship("Company")
```




### Many to Many 多对多

多对多的关系也很常见，比如User和Radio的关系：
一个Radio可以有多个用户可以订阅，一个用户可以订阅多个Radio。

SQL中处理多对多的关系时，是把多对多分拆成两个一对多关系。做法是：新创建一个表，专门存储映射关系。原本的两个表无需设置任何外键。

SQLAlchemy的实践中，也和SQL中的做法一样。

**注意：既然有了专门的Mapping映射表，那么两个表各自就不需要注册任何ForeignKey外键了。**

示例：
```py
# 做出一个专门的表，存储映射关系
# 注意，这个表中两个"id"都不是主键，因为是多对多的关系，所以二者都可以有多条数据。
radio_users = Table('radio_users', Base.metadata,
    Column('whatever_name1', Integer, ForeignKey('radios.id')),
    Column('whatever_name2', Integer, ForeignKey('users.id'))
)

# 定义两个ORM对象：
class Radio(Base):
    __tablename__ = 'radios'

    rid = Column('id', Integer, primary_key=True)
    followers = relationship('User',
        secondary=radio_users,     # `secondary`是专门用来指明映射表的
        back_populates='subscriptions'    # 这个值要对应另一个类的属性名
    )

class User(Base):
    __tablename__ = 'users'

    uid = Column('id', Integer, primary_key=True)
    subscriptions = relationship('Radio',
        secondary=radio_users,
        back_populates='followers'   # 这个值要对应另一个类的属性名
    )
```
其中，`secondary`是专门用来指明映射表的。

> 注意：多对多的时候我们也可以用`backref`参数来添加互相引用。但是这种方法太不直观了，容易产生混乱。所以这里建议用`back_populates`参数，在两方都添加引用，表现一种平行地位，方便理解。

然后插入数据时候是这么用：
```py
radio1 = Radio(..)
radio2 = Radio(..)
radio3 = Radio(..)

user1 = User(..)
user2 = User(..)
user3 = User(..)

# 添加对象间的关联
radio1.subscribers.append( user1 )
radio1.subscribers.append( user2 )

radio2.subscribers.append( user1 )
radio2.subscribers.append( user3 )
```


