# SQLAlchemy中的表关系 Table Relationships 


## 为什么需要手动定义Relationships

在相关联的表中，我们可以不创建表关联的定义，而只是单纯互相引用id即可。但是，查询和使用起来就要麻烦很多：
```py
＃给定参数User.name,获取该user的addresses
# 参考知乎：https://www.zhihu.com/question/38456789/answer/90470689

def get_addresses_from_user(user_name):
    user = session.query(User).filter_by(name=user_name).first()
    addresses = session.query(Address).filter_by(user_id=user.id).all()
    return addresses
```

可以看到，这样的效率非常低。
好在原生的SQL就有relationship设置，SQLAlchemy将其引入到了ORM模型中。

**它可以让我们只在表中声明表之间的关系，之后每次使用就完全无需手动`交叉搜索`，而是像对待一个表中的数据一样直接使用。**



## relationship(..) 函数

SQLAlchemy创建表关联时，使用的是`relationshi(...)`这个函数。
它返回的是一个类的属性，比如father类的`children`属性。但是，它实际上并没有在father表中创建任何叫children的列，而是自动帮你到相关联的children表中去找数据，让你用起来感觉没有差别而已。
这是非常方便的！


### Reference 正向引用

传统的方法，是在父类中定义一个`关系 relationship`或叫`正向引用 Reference`，子类只需定义一个外键。比如：
```py
class Father(..): 
    id = Column(..)
    children = relationship('Child')

class Child(..):
    name = Column(..)
    father_id = Column( Integer, ForeignKey('father.id') )
```
这样当每次我们使用`father.children`的时候，就会自动返回与这个father相关联的所有children了。



### Back Reference 反向引用

单纯定义的`relationship('子类名')`只是一个正向引用，也就是只能让父类调用子对象。反过来，如果要问children他们的父亲是谁，就不行了。

**所以，我们还需要一个`反向引用 (Back Reference)`的声明，让子对象能够知道父对象是谁。**

定义方式是在父类的relationship(..)中加一个参数`backref`：
```py
class Father(..): 
    children = relationship( 'Child', backref='father' )
```
注意：
1. backref参数使用的是**小写名**，因为它指向的是表名，而不是~类名~。
2. backref参数是`双向性`的，意思是，只需要在父类中声明一次，那么`父⇄子`的双向关系就确立了，不用再去子类中写一遍。

这时候，我们在添加就可以这样互相调用了：
```py
>>> Jason = Child('Jason')
>>> print( Jason.father )
```


### Bidirectional & Unidirectional Back Reference 双向和单向的反向引用

后来，SQLAlchemy发现这种只在一边定义双向性`backref`的方法有点不太直观，所以又添加了另一个参数`back_populate`参数，而这个back_populate参数是单向性的，也就是说：
你要确立双方向关系就必须在两边的类中都声明一遍。这样比较直观。

比如：
```py
class Father(..): 
    id = Column(..)
    children = relationship( 'Child', back_populate='father' )

class Child(..):
    father = relationship( 'Father', back_populate='child' )
    father_id = Column( Integer, ForeignKey('father.id') )
```

这样一来利用`反向引用`参数创建的关系就确立了。但是注意，
无论用`backref`还是`back_populate`创建的关联，如果我们必须要为父子对象添加对象间的关联才能引用，否则谁也不知道谁是谁的父亲、儿子：
```py
>>> daddy = Father('David')
>>> son = Child('Jason')

>>> daddy.children
[]
>>> son.father
None

>>> daddy.children.append( son )

>>> daddy.children
[ <Child 'Jason'> ]

>>> son.father
<Father 'David'>
```


`反向引用`参数总结：
- `backref`参数：
- `back_populate`参数：



### Lazy Load 参数

SQLAlchemy的`relationship( ..., lazy='???' )`方法中的`lazy`参数一直是初学最容易困扰的地方。
`Lazy Load Methods`是SQLAlchemy为多表关联而定义的一系列加载方法，每种方法的对应着SQL语句中多表关联的一种写法，所以优缺点、效率高低各有不同。

`lazy`参数的可选方法有：select, immediate, joined, subquery, noload, dynamic
- select - items should be loaded lazily when the property is first accessed, using a separate SELECT statement, or identity map fetch for simple many-to-one references.
- immediate - items should be loaded as the parents are loaded, using a separate SELECT statement, or identity map fetch for simple many-to-one references.
- joined - items should be loaded “eagerly” in the same query as that of the parent, using a JOIN or LEFT OUTER JOIN. Whether the join is “outer” or not is determined by the innerjoin parameter.
- subquery - items should be loaded “eagerly” as the parents are loaded, using one additional SQL statement, which issues a JOIN to a subquery of the original statement, for each collection requested.
- noload - no loading should occur at any time. This is to support “write-only” attributes, or attributes which are populated in some manner specific to the application.
- dynamic - the attribute will return a pre-configured Query object for all read operations, onto which further filtering operations can be applied before iterating the results. See the section Dynamic Relationship Loaders for more details.
- True - a synonym for ‘select’
False - a synonym for ‘joined’
None - a synonym for ‘noload’





## SQL中的表关系

对应关系：
- One to Many 一对多： 
- Many to One 多对一：
- Many to Many 多对多：



### One to Many 一对多

建立一个`One-to-Many`的多表关联，假设是一个人对应多条狗：
```py
# ...
from sqlalchemy.orm import relationship

class Person(Base):
    id = Column(...)
    name = Column(...)
    pets = relationship('Pet', backref='owner')
    # 上面这句是添加一关联，而不是实际的列
    # 注意：1. 'Pet'是大写开头，因为指向了Python类，而不是数据库中表
    # 2. backref是指建立一个不存在于数据库的“假列”，
    # 用于添加数据时候指认关联对象，代替传统id指定


class Pet(Base):
    id = Column(...)
    name = Column(...)
    owner_id = Column(Integer, ForeignKey('person.id')
    # 上面这句添加了一个外键，
    # 注意'person'是用小写以区分，代表是数据库中的表名，而不是class类名
```

创建好关联的表以后，我们就可以直接插入数据了。注意，插入带关联的数据也和SQL插入有些不同：
```py
#...

# 添加主人
andy = Person(name='Andrew')
session.add( andy )
seession.commit()

# 添加狗
pp01 = Pet(name='Puppy', owner=andy)
pp02 = Pet(name='Puppy', owner=andy)
# 注意这句话中，owner是刚才主表中注册relationship中的backref指定的参数名，
# 传给owner的是主表的一个Python实例化对象，而不是什么id
# 看起来复杂，实际上sqlalchemy可以自动取出object的id然后匹配副表中的foreignkey。

session.add(pp01)
session.add(pp02)
session.commit()

print( andy.pets )
# >>> [<Pet 1>, <Pet, 2>]
# 返回的是两个Pet对象

print( pp01.owner )
# >>> <Person 'Andrew'>
# 同样，副表中利用owner这个backref定义的假列，返回的是Person对象。
```





### Many to Many 多对多


多对多的关系也很常见，比如User和Radio的关系：一个Radio可以有多个用户可以订阅，一个用户可以订阅多个Radio。
SQLAlchemy的实践中，这种多对多的关系不直接在两个表中体现。两个表始终是各自独立的没有半点关系。而所有的关系关联都是需要另外抽象出一个单独的表，专门用来存储Mapping映射的关系。


做出一个专门的表，存储映射关系：
```py
subs_mapping = Table( 'subs_mapping'
    Column( 'user_id', Integer, ForeignKey('user.u_id') ),
    Column( 'radio_id', Integer, ForeignKey('radio.r_id') )
)
```
注意，这个表中两个"id"都不是主键，因为是多对多的关系，所以二者都可以有多条数据。

定义两个独立的ORM对象：
```py
class Radio(Model):
    r_id = Column(...)
    r_name = Column(...)

    # 建立反关联
    ref = backref( 'subscribers', lazy='dynamic' )
    # 建立映射关系
    subscriptions = relationship( 'Radio', secondary=subs_mapping, backref=ref )
    # 注意，这个relationship是不在表里体现而只是逻辑上存在的关系
    # 就表来说，各自的数据中是看不出关系的

class User(Model):
    u_id = Column(...)
    u_name = Column(...)
```

然后插入数据时候是这么用：
```py
radio1 = Radio(..)
radio2 = Radio(..)
radio3 = Radio(..)

user1 = User(..)
user2 = User(..)
user3 = User(..)

# 添加有关联的数据
radio1.subscribers.append( user1 )
radio1.subscribers.append( user2 )

radio2.subscribers.append( user1 )
radio2.subscribers.append( user3 )
```
