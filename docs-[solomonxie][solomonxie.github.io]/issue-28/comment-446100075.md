# SQLAlchemy中的表关系 Table Relationships 


## 为什么需要手动定义Relationships

在相关联的表中，我们可以不创建表关联的定义，而只是单纯互相引用id即可。但是，查询和使用起来就要麻烦很多：
```py
＃给定参数User.name,获取该user的addresses
# 参考知乎：https://www.zhihu.com/question/38456789/answer/90470689

def get_addresses_from_user(user_name):
    user = session.query(User).filter_by(name=user_name).first()
    addresses = session.query(Address).filter_by(user_id=user.id).all()
    return addresses
```

可以看到，这样的效率非常低。
好在原生的SQL就有relationship设置，SQLAlchemy将其引入到了ORM模型中。

**它可以让我们只在表中声明表之间的关系，之后每次使用就完全无需手动`交叉搜索`，而是像对待一个表中的数据一样直接使用。**



## relationship(..) 函数

[参考官方文档：Linking Relationships with Backref](https://docs.sqlalchemy.org/en/rel_1_0/orm/backref.html#relationships-backref)

SQLAlchemy创建表关联时，使用的是`relationshi(...)`这个函数。
它返回的是一个类的属性，比如father类的`children`属性。但是，它实际上并没有在father表中创建任何叫children的列，而是自动帮你到相关联的children表中去找数据，让你用起来感觉没有差别而已。
这是非常方便的！


### Reference 正向引用

传统的方法，是在父类中定义一个`关系 relationship`或叫`正向引用 Reference`，子类只需定义一个外键。比如：
```py
class Father(..): 
    id = Column(..)
    children = relationship('Child')

class Child(..):
    name = Column(..)
    father_id = Column( Integer, ForeignKey('father.id') )
```
这样当每次我们使用`father.children`的时候，就会自动返回与这个father相关联的所有children了。



### Back Reference 反向引用

单纯定义的`relationship('子类名')`只是一个正向引用，也就是只能让父类调用子对象。反过来，如果要问children他们的父亲是谁，就不行了。

**所以，我们还需要一个`反向引用 (Back Reference)`的声明，让子对象能够知道父对象是谁。**

定义方式是在父类的relationship(..)中加一个参数`backref`：
```py
class Father(..): 
    children = relationship( 'Child', backref='father' )
```
注意：
1. backref参数使用的是**小写名**，因为它指向的是表名，而不是~类名~。
2. backref参数是`双向性`的，意思是，只需要在父类中声明一次，那么`父⇄子`的双向关系就确立了，不用再去子类中写一遍。

这时候，我们在添加就可以这样互相调用了：
```py
>>> Jason = Child('Jason')
>>> print( Jason.father )
```


### Bidirectional & Unidirectional Back Reference 双向和单向的反向引用

后来，SQLAlchemy发现这种只在一边定义双向性`backref`的方法有点不太直观，所以又添加了另一个参数`back_populate`参数，而这个back_populate参数是单向性的，也就是说：
你要确立双方向关系就必须在两边的类中都声明一遍。这样比较直观。

比如：
```py
class Father(..): 
    id = Column(..)
    children = relationship( 'Child', back_populate='father' )

class Child(..):
    father = relationship( 'Father', back_populate='child' )
    father_id = Column( Integer, ForeignKey('father.id') )
```

这样一来利用`反向引用`参数创建的关系就确立了。但是注意，
无论用`backref`还是`back_populate`创建的关联，如果我们必须要为父子对象添加对象间的关联才能引用，否则谁也不知道谁是谁的父亲、儿子：
```py
>>> daddy = Father('David')
>>> son = Child('Jason')

>>> daddy.children
[]
>>> son.father
None

>>> daddy.children.append( son )

>>> daddy.children
[ <Child 'Jason'> ]

>>> son.father
<Father 'David'>
```


`反向引用`参数总结：
- `backref`参数：
- `back_populate`参数：



### Lazy Load 参数

[参考：flask-sqlalchemy中的lazy的解释](https://shomy.top/2016/08/11/flask-sqlalchemy-relation-lazy/)

SQLAlchemy的`relationship( ..., lazy='???' )`方法中的`lazy`参数一直是初学最容易困扰的地方。

`Lazy Load Methods`是SQLAlchemy为多表关联而定义的一系列加载方法。为lazy参数选择什么值，决定了 SQLAlchemy 什么时候从数据库中加载数据。每种方法的对应着SQL语句中多表关联的一种写法，所以优缺点、效率高低各有不同。

`lazy`参数的可选方法有：
- `select` - (默认) 后台会用select语句一次性加载所有数据，即访问到属性的时候，就会全部加载该属性的数据。
- `joined` - 数据会被JOIN语句加载，即对关联的两个表进行join操作，从而获取到所有相关的对象。
- `subquery` - 数据被用subquery子查询SQL语句加载
- `dynamic` - 在访问属性的时候，并不在内存中加载数据，而是返回一个query对象, 需要执行相应方法才可以获取对象。适用于数据量大的时候。 
- `immediate` - items should be loaded as the parents are loaded, using a separate SELECT statement, or identity map fetch for simple many-to-one references.
- `noload` - no loading should occur at any time. This is to support “write-only” attributes, or attributes which are populated in some manner specific to the application.
- `True` - 即 'select'方法
- `False` - 即 'joined'方法
- `None` - 即'noload'方法


下面用`School`和`Students`的实例来看各种方法的不同。

假设定义两个ORM类：
```py
class School(..):
    id = Column(..)
    students = relationship( 'Student', backref='school' )

class Student(..):
    id = Column(..)
    school_id = Column(.., ForeignKey('school.id') )
```

上例中我们建立了一个普通的两表关联：`students = relationship( 'Student', backref='school' )`。
默认情况下，参数`lazy`为select，我们不写也可以）。
也就是说，如果定义`lazy='select'`，那么当我们要进行搜索引用时（假设表中已有数据）：
```py
>>> school_01 = School.query.first()  # 随便获取一个数据库中已有的school
>>> school_01.students
[ <Student: u'test'>, <Student: u'test2'>, <Student: u'test3'> ]
```
可以看到，`lazy='select'`会简单直接的返回所有相关联的数据。
但是，如果数据量非常大：比如百万级，这种全部返回就不理智了，因为会大量侵占内存。
所以我们可以选择`lazy='dynamic'`，即只返回一个`query`查询对象，供你手动加条件查询，比如`query.all()`或`query.filter()`等。

假设我们将之前的定义改为：`students = db.relationship('Student', backref='_class', lazy="dynamic")`。那么：
```py
>>> school_01.students
<sqlalchemy.orm.dynamic.AppenderBaseQuery object at 0x7f007d2e8ed0>

>>> print( school_01.students )
SELECT students.id AS students_id, students.name AS students_name
FROM students, registrations
WHERE :param_1 = registrations.class_id AND students.id = registrations.student_id

>>> school_01.students.all()
[ <Student: u'test'>, <Student: u'test2'>, <Student: u'test3'> ]
```
可以看到, 执行`school_01.students`返回的只是一个`query`对象，甚至说只是返回了一条SQL
语句，就是没有具体数据。可以想像这个消耗的时间相当于0了。
而如果`lazy=select 或者 joined`均是直接返回结果。　

需要注意的是，
**`lazy="dynamic"`只可以用在一对多和多对对关系中，不可以用在一对一和多对一中。**

这样也合理：如果返回结果很少的话，就没必要延迟加载数据了。 

#### backref(..., lazy='..') 反向引用的lazy加载

直接给`relationship(.., lazy='??')`，只是给`正向引用`设置加载方法。
实际上`反向引用`也是可以设置lazy加载方法的。
做法就是：使用`backref(..)`函数：
```py
    students = relationship(..., lazy='..', backref=backref('Student, lazy='dynamic') )
```
可以看到，`backref(..)`函数返回的是一个`backref`参数专用的值，在这里面可以指定反向引用的加载方法。




## SQL中的表关系

对应关系：
- One to Many 一对多： 
- Many to One 多对一：
- Many to Many 多对多：



### One to Many 一对多

建立一个`One-to-Many`的多表关联，假设是一个人对应多条狗：
```py
# ...
from sqlalchemy.orm import relationship

class Person(Base):
    id = Column(...)
    name = Column(...)
    pets = relationship('Pet', backref='owner')
    # 上面这句是添加一关联，而不是实际的列
    # 注意：1. 'Pet'是大写开头，因为指向了Python类，而不是数据库中表
    # 2. backref是指建立一个不存在于数据库的“假列”，
    # 用于添加数据时候指认关联对象，代替传统id指定


class Pet(Base):
    id = Column(...)
    name = Column(...)
    owner_id = Column(Integer, ForeignKey('person.id')
    # 上面这句添加了一个外键，
    # 注意'person'是用小写以区分，代表是数据库中的表名，而不是class类名
```

创建好关联的表以后，我们就可以直接插入数据了。注意，插入带关联的数据也和SQL插入有些不同：
```py
#...

# 添加主人
andy = Person(name='Andrew')
session.add( andy )
seession.commit()

# 添加狗
pp01 = Pet(name='Puppy', owner=andy)
pp02 = Pet(name='Puppy', owner=andy)
# 注意这句话中，owner是刚才主表中注册relationship中的backref指定的参数名，
# 传给owner的是主表的一个Python实例化对象，而不是什么id
# 看起来复杂，实际上sqlalchemy可以自动取出object的id然后匹配副表中的foreignkey。

session.add(pp01)
session.add(pp02)
session.commit()

print( andy.pets )
# >>> [<Pet 1>, <Pet, 2>]
# 返回的是两个Pet对象

print( pp01.owner )
# >>> <Person 'Andrew'>
# 同样，副表中利用owner这个backref定义的假列，返回的是Person对象。
```





### Many to Many 多对多


多对多的关系也很常见，比如User和Radio的关系：一个Radio可以有多个用户可以订阅，一个用户可以订阅多个Radio。
SQLAlchemy的实践中，这种多对多的关系不直接在两个表中体现。两个表始终是各自独立的没有半点关系。而所有的关系关联都是需要另外抽象出一个单独的表，专门用来存储Mapping映射的关系。


做出一个专门的表，存储映射关系：
```py
subs_mapping = Table( 'subs_mapping'
    Column( 'user_id', Integer, ForeignKey('user.u_id') ),
    Column( 'radio_id', Integer, ForeignKey('radio.r_id') )
)
```
注意，这个表中两个"id"都不是主键，因为是多对多的关系，所以二者都可以有多条数据。

定义两个独立的ORM对象：
```py
class Radio(Model):
    r_id = Column(...)
    r_name = Column(...)

    # 建立反关联
    ref = backref( 'subscribers', lazy='dynamic' )
    # 建立映射关系
    subscriptions = relationship( 'Radio', secondary=subs_mapping, backref=ref )
    # 注意，这个relationship是不在表里体现而只是逻辑上存在的关系
    # 就表来说，各自的数据中是看不出关系的

class User(Model):
    u_id = Column(...)
    u_name = Column(...)
```

然后插入数据时候是这么用：
```py
radio1 = Radio(..)
radio2 = Radio(..)
radio3 = Radio(..)

user1 = User(..)
user2 = User(..)
user3 = User(..)

# 添加有关联的数据
radio1.subscribers.append( user1 )
radio1.subscribers.append( user2 )

radio2.subscribers.append( user1 )
radio2.subscribers.append( user3 )
```
