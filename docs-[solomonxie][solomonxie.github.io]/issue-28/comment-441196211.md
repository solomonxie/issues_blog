# MySQL常用高级操作


## 视图 View

一个View视图是一个`虚拟的表格`，是从各个真实表格中抽取各种数据而成，但是只能查询不能删改。
为什么要用视图？因为一般查询经常会涉及多个表多个字段，非常繁琐。为了简化流程，适合未来业务改变，所以更方便的是抽象出一个视图来查询。

也就是，用View的意义在于：
- 简化复杂的查询语句
- 方便维护，在业务变化后不需要修改大量原表内容
- 可以针对不同的用户显示不同结构的表，但是原表原封不动

定义View视图：
```sql
CREATE VIEW 视图名称 AS
    SELECT ... FROM ... WHERE ... ;
```

定义好后，一个View视图就会成为一个数据库中的“表格”，当我们用`show tables;`时就会显示出来所有的表和视图。

删除视图：
```sh
DROP VIEW 视图名称 ;
```


## 事务 Transaction

一个事务Transactin代表一个`操作序列`，即联动的好几条语句。那么，

当我们将Transaction作为一个_整体_执行时，操作序列中的语句要么**全部执行成功**，要么**全体执行失败**。

在很多时候，这种`操作序列`的绑定是至关重要的。比如A向B进行银行转帐分为这三步：
- [x] 检查A的账户余额是否充足
- [x] 从A的账户扣钱
- [ ] 在B的账户加钱

那么，如果转账系统突然故障，只执行了2步就死机，那么这时候**必须**视为整体执行失败，否则将会引发大问题。

如果一个Transaction中有一个执行失败的语句，那么数据库会立即进行`Rollback`回滚操作。

MySQL中执行事务的语句格式：
```sql
START TRANSACTION ;

    SELECT ... FROM ... ;
    UPDATE ... SET .... ;
    INSERT INTO ... ;

COMMIT;
```
(以上的`Start Transaction ;`也可以用`Begin ;`来代替。)

如果`Commit`报错，那么我们可以进行手动回滚：
```sql
ROLLBACK ;
```

### 事务的四大特性 (ACID)

事务Transaction是保证数据更新100%成功的一种方式。
（注意：事务只是为了增删改而设计的。而单纯的查询，是不需要事务的。）

它具有如下特性：
- `Atomicity` 原子性: 一个事务必须视为不可分割的最小单位，要么全成功，要么全失败。
- `Consistency` 一致性：总是从一个`一致性状态`转到另一个`一致性状态`，没有中间状态。
- `Isolation` 隔离性：当事务没有执行完时，是对外不可见的，也就是这时候数据库还没有完成真正的修改，别人也看不到有任何变动。
- `Durability` 持久性：一旦事务执行成功，那么就真正完成数据库的修改，电脑关机也不会有变动了。



## 索引 Indexing

> 一个网站的读、写比例一般是10: 1，所以查询永远是数据库的大头。

如果一个网站只有几万条数据，那么完全不需要索引。但是一旦到了百万级以上，没有索引的话，每次查询都会造成数秒级的等待！这是用户绝不能忍的。

为了加快查找速度，数据库一般都会有`索引`功能，即类似图书馆中书籍编号的索引。
数据库中的索引是一个特殊文件，存储了 _某个数据库表_ 中 _所有记录_ 的`指针引用`。

而数据库中索引的实现方法，要远比建立图书的索引要复杂很多。(一般不需要深入了解)

MySQL建立的索引是采用数据结构的树形结构，以加速查找效率：

![image](https://user-images.githubusercontent.com/14041622/48945345-eb678c00-ef64-11e8-8c8e-1d7c97d47454.png)




为一个表`tb1`的`title`列创建一个索引`index1`：
```sql
CREATE INDEX index1 ON tb1( title(10) ) ;
```
其中`列名(length)`中的length代表字段的长度，一般对应着char / varchar等类型的长度。

~这时候，MySQL会自动给每条数据的指定列生成一个索引值。然后这些索引也变成了一个列`index1`。这时候我们就可以把这个列加入到表中，然后被查询引用了。~

这时候，系统会生成一个表格，名为`index1`，其中只有两列：索引值、列的原值。

这时候可以直接从索引中搜索了：
```sql
SELECT title FROM index1 ;
```

如果我们用`show profiles ;`就可以看到，与直接查询原表比，当查询数万、百万级数据时，索引快了不是一个数量级。



## 主从 Master-Worker


## 账户管理 Account Management


## 执行时间查看

在MySQL中，可以开启`时间监控`的功能。

```sql
-- 开启时间监控，0为关，1为开
SET profiles = 1 ;

-- 任意执行一个语句
SELECT ... FROM ... ;

-- 显示之前那句的执行时间
SHOW profiles ;
```

显示效果如下（包括具体的sql语句和执行时间）：
![image](https://user-images.githubusercontent.com/14041622/48939381-0202e880-ef4f-11e8-9768-2d9725a1708b.png)

实际上profiles就是一个简单的表，记录了每一次的sql语句和其执行的时间。