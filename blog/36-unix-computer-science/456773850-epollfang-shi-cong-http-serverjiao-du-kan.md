# ❖ epoll方式 (从HTTP Server角度看）[DRAFT]

`epoll`是Linux内核采用的处理多任务高并发的一种方式。不同于多线程、多进程、协程、非阻塞等方式，epoll只通过单进程、单线程即可完成多任务同时处理。

`select`和`poll`是Unix的内核处理多任务方式，而`epoll`是在前两者基础上衍生出来的Linux多任务处理方式。

## 理解epoll

但是epoll和其它那些有本质上的区别：多进程、多线程、协程无论怎么运用，都逃不出`Application`的内存空间，之后还是要一个一个的**复制**到Kernel内核中去运行，而且还不是一口气，需要和其它application应用程序互相穿插着、排队去kernel运行。
但是由于我们要处理的是`高并发socket`问题，那就必然遇到某一些socket等待对方传数据的过程，这就造成了对kernel的极大浪费。

**而`epoll`的作用就是，让我们“跳出”Application的盒子，达到Kernel内核级的运算。**

> 现今所有流行的HTTP Servers都是采用的epoll方式来加速处理多任务，包括Apache、Nginx等。包括协程的Python库gevent也是采用epoll底层处理。所有这些多进程、多线程、协程、非堵塞的方式，在和epoll高效率比起来，都是一个天上一个地下。这也就是为什么epoll这么流行的原因。

`epoll`两大特点：
- **@ 1: 采用`mmap`内存映射技术，使用单独的`epoll`内存空间：**
    - 首先要理解，操作系统的内存分配中，Kernel必须独占空间不能被App应用程序使用（否则相当于被黑客随便使用），App程序的内存空间也是互相隔离开的。
    - 但是每次app都把数据copy到kernel内核中，就导致高并发时效率低下的问题。
    - 于是产生了`epoll`方式：即在内存中创建一片**独立的**空间，让Kernle和App共用。这样一来二者互不干扰，还能互相协作。
- **@ 2: 采用`事件通知`方式，而不使用轮询：**
    - 先要知道，TCP建立一个连接后立马就建立了一个socket文本文件，但是这时候不一定socket中有数据，还要等Client传输。这就是典型的IO堵塞。
    - 当高并发的数万个socket建立时，不一定每个都会及时收到数据，显然采用`轮询`去看谁有数据是不理智的。
    - 干脆不采用轮询，而是像食堂吃饭一样，谁饿了谁喊出来，厨师才去给他做饭。
    - 也就是，只有数据真正传到socket里面来时，才发出事件通知，让Application去处理这个socket。

> Socket Reminder: 
回想HTTP Server的服务，其中TCP三次握手，每次握手、每次挥手、每次上传、每次下载，都是一次向对方电脑的一个socket文本文件写入的过程。
但是从socket文件建立，到写入数据，到完成写入，是有**不确定**的时间间隔的。
只有当这个socket写入完成时，作为应用程序的HTTP Server才会去处理。

**而`epoll`要消除的，就是`socket建立 -> socket写入完成`这之间的堵塞时间。**


## 实现epoll

`epoll`的实现是需要用C语言等最底层的语言去与Linux Kernel沟通才能实现。一般来讲没有kernel级别的编程能力，就只要理解实现原理就够了。

IO多路复用
就是`select`, `poll`, `epoll`，即`Event driven I/O`的IO方式。


基本工作方式：
采用`select -> poll -> epoll`模型，不断循环，不断轮询所有socket，只有当某个socket的数据变化了（接收到数据了），才通知用户进程来处理。
